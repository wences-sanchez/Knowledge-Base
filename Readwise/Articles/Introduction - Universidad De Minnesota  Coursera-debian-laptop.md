# Introduction - Universidad De Minnesota | Coursera

deck:: [[Across-the-Net]]\
author:: [[coursera.org]]\
full-title:: "Introduction - Universidad De Minnesota | Coursera"\
category:: #articles\
url:: https://www.coursera.org/learn/introduction-software-testing/lecture/ohzH2/introduction\

![](https://readwise-assets.s3.amazonaws.com/static/images/article1.be68295a7e40.png)
## Highlights
- id:: 63639907-7401-4de2-976b-556a61abc672
   This is just an example of testing without being criticist against the application. #flashcard 
    So a developer writes two or three tests, they run it through the program.
-
- id:: 63639907-62c1-4371-a4b8-88138826ab51
   What is the objective of the first course? #flashcard 
    And so what we're going to do, what our goal is for this course, is to make testing effective despite its incompleteness.
-
- id:: 63639907-04e2-4c14-8355-ec6208c6de8f
  
  Even simple software has lots and lots possible tests that you can run against it. #flashcard
-
- id:: 63639907-4f54-47e0-a731-9d6401a97bd6
  
  But testing is always incomplete. #flashcard
-
- id:: 63639907-6e2d-41f5-8ea7-6fde80111c97
  
  So when you build something for, say, the United States government or another company, they not only want the software but they usually want a test suite that demonstrates the software does what it's supposed to do. #flashcard
-
- id:: 63639907-1419-475e-9d0f-77c7a64d02a8
  
  Another reason we want to use testing is that oftentimes it's just necessary for the customer to accept the system. #flashcard
-
- id:: 63639907-ddd0-4abc-9eab-0f0020808d99
  
  And that intended environment not only includes the software you write but the software you use and the hardware it runs on. #flashcard
-
- id:: 63639907-3bb1-4b85-893a-1c3294ebecd2
  
  Things like, does it have any integer overflows, or null pointer dereferences? And then testing, which is of course the focus of this course, where we have the software product itself, and and we're seeing if it does the right thing. #flashcard
-
- Testing es uno más de las técnicas de V&V. Others are:
	- Inspections
	- Design discussions
	- Static Analysis
	- Runtime Verification
	- [Testing] #flashcard 
	  id:: 63639907-f6ee-4a75-89e1-a871df8c3720
-
- id:: 63639907-243c-4f30-b822-7065a151d0e5
  
  And why are we focusing on this area of verification and validation rather than all the others? Well, software testing is the only defect detection technique that can check the whole system. #flashcard
-
- id:: 63639907-e167-4757-b732-ad8a7fd2e69c
  
  The key point is that Software Testing is the only software detection technique that can check the whole system #flashcard
-
- id:: 63639907-64ad-4528-9f47-d555b8bca281
  
  And the next thing we want to do is we want to apply multiple V&V, that is verification and validation techniques, throughout the development cycle. #flashcard
-
- id:: 63639907-57ff-4850-92b6-5f989777584b
   Why testing? #flashcard 
    So our first question may be, why do we test? Why is it hard? It turns out that writing software is hard, and programmers make mistakes. And if we don't adequately test our systems, we may end up on front page news.
-
- id:: 63639907-8b10-4578-9bcd-735be322dd5a
   What do we want from testing? #flashcard 
    And we rely on software testing to help us get it right.
-
- id:: 63639907-ae2c-4e13-9699-4e0bb389b85b
   V&V explained #flashcard 
    To make sure software performs as expected, we have to do two things well. Those are verification and validation. And what we're trying to do is make sure that the software is going to meet the user's needs. So the first thing that we do is verification. This asks the question, "Are we building the software right?" So in this case, we assume we have some requirements and what we're trying to check is that the software conforms to its requirements. This is, of course, very important and a lot of the focus of software testing. But, another thing that we have to do is something called validation. And that is, "are we building the right product?" So maybe our requirements are wrong, and it doesn't actually meet the user's needs. So we have to perform a level of validation to make sure at the end of the process, and actually throughout, that we're building something not only that meets what we think the product should do, but also our customers think the product should do.
-