# Introduction - Universidad De Minnesota | Coursera

deck:: [[Across-the-Net]]\
author:: [[coursera.org]]\
full-title:: "Introduction - Universidad De Minnesota | Coursera"\
category:: #articles\
url:: https://www.coursera.org/learn/introduction-software-testing/lecture/ohzH2/introduction\

![](https://readwise-assets.s3.amazonaws.com/static/images/article1.be68295a7e40.png)
## Highlights
- id:: 63c669d1-a9c1-49ee-96b7-003676b8a0c1
   This is just an example of testing without being criticist against the application. #flashcard 
    So a developer writes two or three tests, they run it through the program.
-
- id:: 63c669d1-00af-4d8f-8f55-633498823caa
   What is the objective of the first course? #flashcard 
    And so what we're going to do, what our goal is for this course, is to make testing effective despite its incompleteness.
-
- id:: 63c669d1-283d-498d-b06f-00d6917e29ca
  
  Even simple software has lots and lots possible tests that you can run against it. #flashcard
-
- id:: 63c669d1-56f9-4436-b1df-7d3a5e5c3586
  
  But testing is always incomplete. #flashcard
-
- id:: 63c669d1-d5e7-446c-bc4d-97f62065055b
  
  So when you build something for, say, the United States government or another company, they not only want the software but they usually want a test suite that demonstrates the software does what it's supposed to do. #flashcard
-
- id:: 63c669d1-6346-4d3b-9b34-23123e1f1010
  
  Another reason we want to use testing is that oftentimes it's just necessary for the customer to accept the system. #flashcard
-
- id:: 63c669d1-a506-44a3-858c-abb25edc7ec5
  
  And that intended environment not only includes the software you write but the software you use and the hardware it runs on. #flashcard
-
- id:: 63c669d1-5b34-4ced-955c-ca5b2fc94b79
  
  Things like, does it have any integer overflows, or null pointer dereferences? And then testing, which is of course the focus of this course, where we have the software product itself, and and we're seeing if it does the right thing. #flashcard
-
- Testing es uno más de las técnicas de V&V. Others are:
	- Inspections
	- Design discussions
	- Static Analysis
	- Runtime Verification
	- [Testing] #flashcard 
	  id:: 63c669d1-80ac-4769-98d7-b65c19c6c37e
-
- id:: 63c669d1-2c3f-43c4-8319-fe72966487b3
  
  And why are we focusing on this area of verification and validation rather than all the others? Well, software testing is the only defect detection technique that can check the whole system. #flashcard
-
- id:: 63c669d1-cc70-48c7-98a0-d8e280f5518d
  
  The key point is that Software Testing is the only software detection technique that can check the whole system #flashcard
-
- id:: 63c669d1-827f-4f7d-8301-667a8a10d849
  
  And the next thing we want to do is we want to apply multiple V&V, that is verification and validation techniques, throughout the development cycle. #flashcard
-
- id:: 63c669d1-62cd-4507-8b7b-60333e8b6bad
   Why testing? #flashcard 
    So our first question may be, why do we test? Why is it hard? It turns out that writing software is hard, and programmers make mistakes. And if we don't adequately test our systems, we may end up on front page news.
-
- id:: 63c669d1-9f62-4a41-a796-f5efe652b825
   What do we want from testing? #flashcard 
    And we rely on software testing to help us get it right.
-
- id:: 63c669d1-0d0f-45f2-974a-ecf52abcc026
   V&V explained #flashcard 
    To make sure software performs as expected, we have to do two things well. Those are verification and validation. And what we're trying to do is make sure that the software is going to meet the user's needs. So the first thing that we do is verification. This asks the question, "Are we building the software right?" So in this case, we assume we have some requirements and what we're trying to check is that the software conforms to its requirements. This is, of course, very important and a lot of the focus of software testing. But, another thing that we have to do is something called validation. And that is, "are we building the right product?" So maybe our requirements are wrong, and it doesn't actually meet the user's needs. So we have to perform a level of validation to make sure at the end of the process, and actually throughout, that we're building something not only that meets what we think the product should do, but also our customers think the product should do.
-