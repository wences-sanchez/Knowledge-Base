# Computer Science Illuminated

deck:: [[O'Reilly-Learning::Computer Science Illuminated]]\
author:: [[None]]\
full-title:: "Computer Science Illuminated"\
category:: #books\
\
tags:: O'Reilly-Learning  

![](https://learning.oreilly.com/library/view/computer-science-illuminated/9781284155648/ibis_generated_cover_thumbnail.jpg)
## Highlights
### 1.1 Computing Systems
- id:: 63c669ec-d1ec-479a-a816-f86a87766aba
   __information hiding__ #flashcard 
    Information hiding is a design feature that gives rise to the abstractions that make something easier to work with. Information hiding and abstraction are two sides of the same coin.
-
### 1.2 The History of Computing
- id:: 63c669ec-60b5-44e3-bdf2-ba7cd3751f93
  
  First Generation (1951–1959)
     Commercial computers in the first generation (from approximately 1951 to 1959) were built using vacuum tubes to store information. #flashcard
-
- id:: 63c669ec-9432-4d94-89a7-04362e28300f
  
  Second Generation (1959–1965)
     The advent of the transistor (for which John Bardeen, Walter H. Brattain, and William B. Shockley won a Nobel Prize) ushered in the second generation of commercial computers. The transistor replaced the vacuum tube as the main component in the hardware. #flashcard
-
- id:: 63c669ec-3007-4372-8c74-09b0e668fd32
  
  Third Generation (1965–1971)
     In the second generation, transistors and other components for the computer were assembled by hand on printed circuit boards. The third generation was characterized by integrated circuits (ICs), solid pieces of silicon that contained the transistors, other components, and their connections. Integrated circuits were much smaller, cheaper, faster, and more reliable than printed circuit boards. #flashcard
-
- id:: 63c669ec-a3c0-4d66-a7c9-5121c38e998d
   __Transistors #flashcard 
    Transistors also were used for memory construction, where each transistor represented one bit of information. Integrated-circuit technology allowed memory boards to be built using transistors. Auxiliary storage devices were still needed because transistor memory was volatile; that is, the information went away when the power was turned off.
-
- id:: 63c669ec-3a97-4975-b1d4-5f828221508b
  
  Fourth Generation (1971–?)
     Large-scale integration characterizes the fourth generation. From several thousand transistors on a silicon chip in the early 1970s, we had moved to a whole microcomputer on a chip by the middle of this decade. Main memory devices are still made almost exclusively out of chip technology. #flashcard
-
- id:: 63c669ec-f32b-46c3-81de-ee7941d796f8
  
  Parallel architectures offer several ways to increase the speed of execution. For example, a given step in a program can be separated into multiple pieces, and those pieces can be executed simultaneously on several individual processors. These machines are called SIMD (single-instruction, multiple-data-stream) computers. A second class of machines can work on different parts of a program simultaneously. These machines are called MIMD (multiple-instruction, multiple-data-stream) computers. #flashcard
-
- id:: 63c669ec-20c8-47e2-b8d2-c3c45916baeb
  
  A Brief History of Computing Software #flashcard
-
- id:: 63c669ec-0f89-480b-9196-595be434a3b3
  
  First-Generation Software (1951–1959)
     The first programs were written using machine language, the instructions built into the electrical circuitry of a particular computer. Even the small task of adding two numbers together used three instructions written in binary (1s and 0s), and the programmer had to remember which combination of binary digits meant what. #flashcard
-
- id:: 63c669ec-4f9b-4980-98cf-1e1cd0512c39
  
  Because writing in machine code is so tedious, some programmers took the time to develop tools to help with the programming process. Programmers began writing programs in assembly language, which used mnemonic codes to represent each machine-language instruction. #flashcard
-
- id:: 63c669ec-5ac9-4d4d-8ff3-1189666a53ac
  
  Second-Generation Software (1959–1965)
     As hardware became more powerful, more powerful tools were needed to use it effectively. Assembly languages certainly presented a step in the right direction, but the programmer still was forced to think in terms of individual machine instructions. The second generation saw more powerful languages developed. These high-level languages allowed the programmer to write instructions using more English-like statements. #flashcard
-
- id:: 63c669ec-02b2-47d3-bd90-748877ddcd0c
   __operating system #flashcard 
    Third-Generation Software (1965–1971)
     During the third generation of commercial computers, it became apparent that the human was slowing down the computing process. Computers were sitting idle while waiting for the computer operator to prepare the next job. The solution was to put the computer resources under the control of the computer—that is, to write a program that would determine which programs were run when. This kind of program was the first operating system.
-
- id:: 63c669ec-38dc-4656-95bb-9fde96eab093
   About servers #flashcard 
    For the user, time sharing is much like having his or her own machine. Each user is assigned a small slice of central processing time and then is put on hold while another user is serviced. Users generally aren’t even aware that there are other users. However, if too many people try to use the system at the same time, there can be a noticeable wait for a job to be completed.
-
- id:: 63c669ec-0c1f-42e9-b683-335b77bf6f4c
   systems VS applications programmers #flashcard 
    By the end of the first generation, programmers had emerged who wrote tools for other programmers to use, giving rise to the distinction between systems programmers and applications programmers. However, the programmer was still the user. In the third generation, systems programmers were writing software for nonprogrammers to use. For the first time, there were computer users who were not programmers in the traditional sense.
-
- id:: 63c669ec-310e-44b5-bd0d-7021bd1483bf
  
  Fourth Generation (1971–1989)
     The 1970s saw the introduction of better programming techniques called structured programming, a logical, disciplined approach to programming. The languages Pascal and Modula-2 were built on the principles of structured programming. BASIC, a language introduced for third-generation machines, was refined and upgraded to more structured versions. C, a language that allows the user to intersperse assembly-language statements in a high-level program, was also introduced. C++, a structured language that allows the user access to low-level statements as well, became the language of choice in the industry. #flashcard
-
- id:: 63c669ec-f752-4315-bf20-20ee363c21d4
  
  Fifth Generation (1990–Present)
     The fifth generation is notable for three major events: the rise of Microsoft® as a dominant player in computer software, object-oriented design and programming, and the World Wide Web. #flashcard
-
- id:: 63c669ec-dbff-4b6b-8e28-fee7a2700e44
  
  Although the Internet had been around for decades, the World Wide Web made it easy to use the Internet to share information around the world. User-generated and user-edited content became the norm. #flashcard
-