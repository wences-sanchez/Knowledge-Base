# OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815

deck:: [[Other-Books::OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815]]\
author:: [[Hanumant Deshmukh]]\
full-title:: "OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815"\
category:: #books\
\

![](https://images-na.ssl-images-amazon.com/images/I/51hydbMukbL._SL200_.jpg)
## Highlights
- id:: 6363992a-cd68-497b-a61a-d36699516e57
  
  I will recommend you to buy the exam simulator created by this team from our website Enthuware.com. It is priced quite reasonably (only 9.99 USD) and has stood the test of time. #flashcard  #pink #rosa 
  
  
    ([Location 266](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=266))
-
- id:: 6363992a-ded3-4bf0-8af1-7c03f249aeac
  
  Instead of presenting MCQs or quizzes at the end of a topic or chapter, I ask you to write code that uses the concepts taught in that topic or chapter. #flashcard 
  
  
    ([Location 297](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=297))
-
- id:: 6363992a-0f20-459f-87a7-94236bae5757
  
  I strongly suggest you use Enthuware's exam simulator to get familiar with this style. It closely mimics the user interface of the real exam. #flashcard 
  
  
    ([Location 306](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=306))
-
- id:: 6363992a-5e21-4705-81d5-513ed70ba16e
  
  API stands for Application Programming Interface #flashcard 
  
  
    ([Location 447](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=447))
-
- id:: 6363992a-70f9-4b02-9154-7d2eb06175b6
  
  The key point about an interface is that you cannot have an instance of an interface #flashcard 
  
  
    ([Location 488](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=488))
-
- id:: 6363992a-70cc-4c26-9833-2feaf37d813f
  
  For example, you cannot really have just a Movable. #flashcard 
  
  
    ([Location 489](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=489))
-
- id:: 6363992a-dd06-48ec-ab92-f0086f930690
  
  In that sense, an interface is always abstract. It cannot exist on its own. You need a class to implement the behavior described by an interface. #flashcard  #blue #azul 
  
  
    ([Location 490](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=490))
-
- id:: 6363992a-cc6d-44d9-8e1b-7d61e8ef73e0
  
  An abstract class lies somewhere in between a class and an interface. Just like a class, it defines behavior as well as implementation but the implementation that it provides is not complete enough for you to create instances of it. Therefore, just like an interface, it cannot exist on its own. #flashcard  #blue #azul 
  
  
    ([Location 492](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=492))
-
- id:: 6363992a-1774-4e98-884a-7bf94b6b4065
  
  C++ has pointer arithmetic, global functions, operator overloading, extern declarations, preprocessor directives, unsigned data types, and so many other "features" that Java simply does not have. These are some really powerful tools in the hands of a C++ programmer. So, why doesn't Java have them? Java has actually gone in reverse with respect to features. Java does not have a lot of features that are found in languages that came before Java. The reason is simple. Java follows the philosophy of making life simpler for the programmer. Having more and more features is not necessarily a good thing. #flashcard 
  
  
    ([Location 522](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=522))
-
- id:: 6363992a-8e32-4c2c-9a1a-cc0fd6e0dea6
  
  since Java 8, interfaces contain method declarations as well as definitions. #flashcard  #pink #rosa 
  
  
    ([Location 588](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=588))
-
- id:: 6363992a-b2f1-48b8-b7ba-1013d9792abd
  
  String str = 0; //will not compile int n = null; //will not compile. #flashcard  #blue #azul 
  
  
    ([Location 655](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=655))
-
- id:: 6363992a-3f5e-4a90-bfbc-a72e173c4433
  
  It should now be clear that a program needs two kinds of memory spaces to keep the stuff. One for temporary stuff that can be cleaned up as soon as a method call ends and one for permanent stuff that remains in use for longer than a single method call. The space for storing the temporary stuff is called Stack space and the space for storing all other stuff is called Heap space #flashcard  #blue #azul 
  
  
    ([Location 706](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=706))
-
- id:: 6363992a-5596-47ff-bd57-47587e76faeb
  
  When a thread dies, its stack space is reverted back to the JVM. Since this space behaves like a stack, it is called stack space #flashcard  #blue #azul 
  
  
    ([Location 732](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=732))
-
- id:: 6363992a-1659-43ce-b6eb-c231b83842d4
  
  Local variables are always kept on the stack. Objects are always stored in the heap. #flashcard  #pink #rosa 
  
  
    ([Location 750](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=750))
-
- id:: 6363992a-dd94-4450-bd97-71cb0b4e82fb
  
  JVM may have several threads. Each thread is given a fixed amount of stack space that is dedicated completely and exclusively to that thread. No one but that thread can access its stack space. This is called "stack semantics".  A thread accesses its stack space by creating and using variables. There is no other special way of accessing the stack space. #flashcard  #pink #rosa 
  
  
    ([Location 752](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=752))
-
- id:: 6363992a-2935-4576-b3a0-f060d354884c
  
  Heap space is shared among all threads. Any thread can use space on a heap by creating objects. Since heap space is shared, it is possible for one thread to access objects created by another if it has a reference to that object. This is called "heap semantics". #flashcard  #pink #rosa 
  
  
    ([Location 755](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=755))
-
- id:: 6363992a-dbcd-4d38-9d90-e8c633cfa4a1
  
  Stack space is limited for a program. So, if you have a huge chain of method calls where each method creates a lot of temporary variables (recursion is a good example), it is possible to run out of stack space. In Java, the default stack space size is 64KB but it can be changed at the time of executing the program using command line option -Xss. Heap space is unlimited from the program's perspective. It is limited only by the amount of space available on your machine. #flashcard  #pink #rosa 
  
  
    ([Location 756](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=756))
-
- id:: 6363992a-fa4b-4020-8c78-227e7ed65aa6
  
  Only temporary variables, i.e., variables created in a method (also known as local variables and automatic variables) are created on the stack space. Everything else is created on the heap space. If you have any doubt, ask yourself this question - is this a temporary variable created in a method? #flashcard  #pink #rosa 
  
  
    ([Location 760](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=760))
-
- id:: 6363992a-a642-4675-84d4-a790df538dc3
  
  When a method is invoked by a thread, it uses the thread's stack space to keep its temporary variables. #flashcard  #pink #rosa 
  
  
    ([Location 763](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=763))
-