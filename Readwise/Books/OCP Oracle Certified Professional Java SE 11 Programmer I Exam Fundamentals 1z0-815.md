# OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815

deck:: [[Other-Books::OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815]]\
author:: [[Hanumant Deshmukh]]\
full-title:: "OCP Oracle Certified Professional Java SE 11 Programmer I Exam Fundamentals 1z0-815"\
category:: #books\
\

![](https://images-na.ssl-images-amazon.com/images/I/51hydbMukbL._SL200_.jpg)
## Highlights
- id:: 63c66a16-ad2c-4c07-89da-8db2fcf46a9b
  
  I will recommend you to buy the exam simulator created by this team from our website Enthuware.com. It is priced quite reasonably (only 9.99 USD) and has stood the test of time. #flashcard  #pink #rosa 
  
  
    ([Location 266](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=266))
-
- id:: 63c66a16-14b1-4a25-9582-2250b81f7c09
  
  Instead of presenting MCQs or quizzes at the end of a topic or chapter, I ask you to write code that uses the concepts taught in that topic or chapter. #flashcard 
  
  
    ([Location 297](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=297))
-
- id:: 63c66a16-6ffa-4f12-b7f7-89758144200a
  
  I strongly suggest you use Enthuware's exam simulator to get familiar with this style. It closely mimics the user interface of the real exam. #flashcard 
  
  
    ([Location 306](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=306))
-
- id:: 63c66a16-cdf9-4303-b303-09faa8e351b9
  
  API stands for Application Programming Interface #flashcard 
  
  
    ([Location 447](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=447))
-
- id:: 63c66a16-0d85-425c-b82d-140a2c580c1e
  
  The key point about an interface is that you cannot have an instance of an interface #flashcard 
  
  
    ([Location 488](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=488))
-
- id:: 63c66a16-ea2a-4b94-bc0e-417b699eb46f
  
  For example, you cannot really have just a Movable. #flashcard 
  
  
    ([Location 489](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=489))
-
- id:: 63c66a16-0b8e-493c-90b7-3f59e9482c6a
  
  In that sense, an interface is always abstract. It cannot exist on its own. You need a class to implement the behavior described by an interface. #flashcard  #blue #azul 
  
  
    ([Location 490](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=490))
-
- id:: 63c66a16-68af-4c03-847e-57cc8da1ede3
  
  An abstract class lies somewhere in between a class and an interface. Just like a class, it defines behavior as well as implementation but the implementation that it provides is not complete enough for you to create instances of it. Therefore, just like an interface, it cannot exist on its own. #flashcard  #blue #azul 
  
  
    ([Location 492](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=492))
-
- id:: 63c66a16-0915-4039-a847-e03126776125
  
  C++ has pointer arithmetic, global functions, operator overloading, extern declarations, preprocessor directives, unsigned data types, and so many other "features" that Java simply does not have. These are some really powerful tools in the hands of a C++ programmer. So, why doesn't Java have them? Java has actually gone in reverse with respect to features. Java does not have a lot of features that are found in languages that came before Java. The reason is simple. Java follows the philosophy of making life simpler for the programmer. Having more and more features is not necessarily a good thing. #flashcard 
  
  
    ([Location 522](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=522))
-
- id:: 63c66a16-a69b-4d66-9dbd-1e610f9ba975
  
  since Java 8, interfaces contain method declarations as well as definitions. #flashcard  #pink #rosa 
  
  
    ([Location 588](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=588))
-
- id:: 63c66a16-b8a0-47ad-9fd5-59d170fa81e7
  
  String str = 0; //will not compile int n = null; //will not compile. #flashcard  #blue #azul 
  
  
    ([Location 655](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=655))
-
- id:: 63c66a16-df79-4184-8ae9-7329f98dfc10
  
  It should now be clear that a program needs two kinds of memory spaces to keep the stuff. One for temporary stuff that can be cleaned up as soon as a method call ends and one for permanent stuff that remains in use for longer than a single method call. The space for storing the temporary stuff is called Stack space and the space for storing all other stuff is called Heap space #flashcard  #blue #azul 
  
  
    ([Location 706](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=706))
-
- id:: 63c66a16-1d09-49ba-975a-f51c7a270624
  
  When a thread dies, its stack space is reverted back to the JVM. Since this space behaves like a stack, it is called stack space #flashcard  #blue #azul 
  
  
    ([Location 732](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=732))
-
- id:: 63c66a16-2aa9-4190-9216-c03faf087040
  
  Local variables are always kept on the stack. Objects are always stored in the heap. #flashcard  #pink #rosa 
  
  
    ([Location 750](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=750))
-
- id:: 63c66a16-fead-4c89-9e9d-8e5f5baa63e9
  
  JVM may have several threads. Each thread is given a fixed amount of stack space that is dedicated completely and exclusively to that thread. No one but that thread can access its stack space. This is called "stack semantics".  A thread accesses its stack space by creating and using variables. There is no other special way of accessing the stack space. #flashcard  #pink #rosa 
  
  
    ([Location 752](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=752))
-
- id:: 63c66a16-73d1-4146-a2d4-dcb57f33c4ab
  
  Heap space is shared among all threads. Any thread can use space on a heap by creating objects. Since heap space is shared, it is possible for one thread to access objects created by another if it has a reference to that object. This is called "heap semantics". #flashcard  #pink #rosa 
  
  
    ([Location 755](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=755))
-
- id:: 63c66a16-a145-4987-87b9-2ed5d698a4b7
  
  Stack space is limited for a program. So, if you have a huge chain of method calls where each method creates a lot of temporary variables (recursion is a good example), it is possible to run out of stack space. In Java, the default stack space size is 64KB but it can be changed at the time of executing the program using command line option -Xss. Heap space is unlimited from the program's perspective. It is limited only by the amount of space available on your machine. #flashcard  #pink #rosa 
  
  
    ([Location 756](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=756))
-
- id:: 63c66a16-0405-4899-b56d-2e67375990d8
  
  Only temporary variables, i.e., variables created in a method (also known as local variables and automatic variables) are created on the stack space. Everything else is created on the heap space. If you have any doubt, ask yourself this question - is this a temporary variable created in a method? #flashcard  #pink #rosa 
  
  
    ([Location 760](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=760))
-
- id:: 63c66a16-b05e-4b9c-bb80-10b45702b9fd
  
  When a method is invoked by a thread, it uses the thread's stack space to keep its temporary variables. #flashcard  #pink #rosa 
  
  
    ([Location 763](https://readwise.io/to_kindle?action=open&asin=B07VWMD2LB&location=763))
-