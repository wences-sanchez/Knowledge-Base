-
- #tags #O'Reilly-Learning #Bash #Videos
- ## Module 1: Before Writing your First Shell Script
-
- ### Lesson 1: Setting up the Course Environment
-
- #spaced
- ### Lesson 2: Getting Familiar with Bash
-
- STDIN, STDOUT and STDERR are file descriptors. They are flexible and dynamically allocated.
-
- A way of getting info about commands is: `help|info|man <command>`
-
- If you put any character just after the name of a variable, the shell will believe that is part of the name and will do nothing but prints a space
-
- **alias** is a Bash internal command that allows us to define our own ones to sum up tasks
	- With `alias` you can print all the aliased commands
	- With `alias brief='my command'` you can write your own alias
	- With `unalias <alias>` you can delete a created alias
-
- Bash startup files are used to provide default settings for the operating system enviroment.
	- These startup files are shell scripts themselves
		- **/etc/profile** is a generic startup fiel that is started for every login shell
		- **/etc/bashrc** is a generic startup file that is started when opening a subshell
		- User specific files are:
			- **~/.bash_profile**
			- **~/.bashrc**
- Bourne shell (**/bin/sh**) was the original shell
- Bash is Bourn Again SHell, a remake of the original Bourne shell that was invented in the 70's
	- The default shell on most Linux distros
- About exit codes:
	- If 0, the command was executed successfully
	- If 1, there was a generic error
	- The developer of a program can decide to code other exit codes as well
		- This is done by **exit n**
- ---
	- #### Flashcards
		- Explain what is alias #flashcard
			- **alias** is a Bash internal command that allows us to define our own ones to sum up tasks
				- With `alias` you can print all the aliased commands
				- With `alias brief='my command'` you can write your own alias
				- With `unalias <alias>` you can delete a created alias
-
	- Name the files which contain the default settings of the shell boots #flashcard
		- Bash startup files are used to provide default settings for the operating system enviroment.
			- These startup files are shell scripts themselves
				- **/etc/profile** is a generic startup fiel that is started for every login shell
				- **/etc/bashrc** is a generic startup file that is started when opening a subshell
				- User specific files are:
					- **~/.bash_profile**
					- **~/.bashrc**
		- About exit codes: #flashcard
			- If 0, the command was executed successfully
			- If 1, there was a generic error
			- The developer of a program can decide to code other exit codes as well
				- This is done by **exit n**
-
- ---
- #spaced
- ### Lesson 3: Shell scripts in a DevOps environment
-
- The purpose of DevOps is to shorten the system development life cycle.
-
- [[12-factor Apps]]
-
- **Idempotency** is a very important aspect
-
- **printf** exists in Bash because of C-Shell, which was C code.
-
- For more advanced and more complex tasks, it might have sense develop a **Python** script. But **Bash** will be native (and maybe more suitable for not-so-complex tasks), so in the real world you have to learn both.
- ---
-
- #spaced
- ### Lesson 4: Learning Linux Essentials for Shell Scripting
-
	- The command in Bash for printing message and be respectful about special characters is:
		- **echo -e** is for special characters
		- `$ echo -e "Estoy partido\nen dos"`
		- **printf** is an alternative, but is more like C-Shell...
	-
	- **printf** does not print a new line character by default.
		- It's more complicated because of its syntax.
		- That's because many people prefer using **echo -e**
		- But try to avoid it because it's a little tricky ðŸ˜‰.
	- #### Grep command
		- **grep** is an external command that helps you filter text
		- It's recommended to put the text pattern between **single quotes** to avoid interpretation by the shell**!!!**
			- **Because we don't want those regular expressions to be interpreted by the shell.**
		- You can use -B n and -A n where n is the number of lines before and after the match in its context
		- If you use -l the output shows only the name of the matched files
	- #### Regexps
		- It's always important to understand them
		- You have to be careful with **Extended Regular Expressions!** So you should use **grep -E**
		- **cut** allows you to filter out fields, based on a field separator
			- `$ cut -d : -f 1 /etc/passwd`
	- **sort** allows you to sort items
		- **sort -n** for numeric sort (to order numbers properly)
		- **sort -d** for dictionary order
		-
		- **sed** is a powerful command which was created when UI didn't exist. An example
			- `$ sed -i 's/bot/bet/' myfile`
				- changes the occurrences of bot to bet
			- `$ sed -i -e '2d' myfile`
				- deletes the second line of myfile
		- **awk** is great to filter text, the same age as *sed*. Example:
			- `$ awk -F : '/wences/ { print $4 }' /etc/passwd`
				- Shows the id of user wences
		- You **shouldn't** use **external tools**. Because they are on disk so that they will be very slow in your scripts.
			- You can use **type <command>** to check them
- #### Lab-4
- ![image.png](../assets/image_1658832196013_0.png)
	- Remember that when a variable of some Linux file is required to be processed, you just have to find the column or the delimiters that round it #dev-notes
	- With **awk -F : '{ print $0 }'**, we print the whole line #dev-notes
- ---
- #### Flashcards
- Tell me the command in Bash for printing message and be respectful about special characters #flashcard
	- **echo -e** is for special characters
	- `$ echo -e "Estoy partido\nen dos"`
	- **printf** is an alternative, but is more like C-Shell...
-
- ---
- ## Module 2: Shell Scripting Fundamentals
-
- #spaced
- ### Lesson 5: Creating your First Shell Script
	- Things to consider when writing scritps:
		- 1. Put the shebang: `#!/bin/bash`
		  2. 2. Comment, comment, comment... :D Also for yourself!!!!
		  3. Use white lines
		  4. Organize your code in blocks
		  5. Extensions of the names are useful when in Windows
		  6. Always finish with an *exit N*
-
	- The scripts cannot be executed from a relative path because of security concerns of Linux
-
	- The token $? returns the exit-code of the las command
-
	- #### Resources for help
	- **help** provides an overview
	- **man bash** offers more information
		- You can search it with `/`
	- But the best resource is:
		- [Advanced Bash-Scripting Guide](https://tldp.org/LDP/abs/html/)
		- [Bash Guide for Beginners](https://tldp.org/LDP/Bash-Beginners-Guide/html/Bash-Beginners-Guide.html)
-
- #### Lab
- ![image.png](../assets/image_1658837096262_0.png)
- ---
- #### Flashcards
	- Why do we have to indicate the exact path when calling a script in Linux? #flashcard
		- The scripts cannot be executed from a relative path because of security concerns of Linux
	- How do we know the exit code of the last command? #flashcard
		- The token $? returns the exit-code of the las command
	- What do you have to type in Google to search Bash stuff? #flashcard
		- *Bash Scripting Guide*
	- How could you make a script to call it wherever? #flashcard
		- By:
			- `$ export PATH=$PATH:$( pwd )`
			- With *:* because that's the path delimiter
		- Or:
			- `$ sudo cp myscript /usr/local/bin`
- ---
- #spaced
- ### Lesson 6: Working with Variables and Arguments
	- An **argument** is anything that can be put behind the name of a command or script
		- **ls -l /etc** has 2 arguments
	- An **option** is an argument that changes the behavior of the command or script, and its functionality is programmed into the command
		- In **ls -l /etc**, **-l** is used as an option
	- A **posicional parameter** is another word for an argument.
		- It's the same thing as argument. But argument is a preferred name.
	- A **variable** is a key with a name that can refer to a specific value
-
	- About quotes in Bash:
		- **Double quotes** (or **weak** quotes)are used to avoid interpretation of **spaces**
			- echo "my value"
		- **Single quotes** (or **strong** quotes)are used to avoid interpretation of **anything**
			- echo the current '$SHELL' is $SHELL
	- Bash don't use data types
	- **declare** can be used to set specific variable attributes:
		- **declare -r ANSWER=yes** sets *$ANSWER* as a read-only variable
		- **declare [-a|-A] MYARRAY** is used to define an indexed (or associative) array.
		- **declare -p var** tells you about *var*
	-
	- **In Bash, the variables are NOT case sensitive**
-
	- When **read** is used, the shell script execution will stop to read user input
		- ```
		- echo enter a value
		- read value # or more
		- echo you have entered $value # or more
		- ```
-
	- If we start a script, we'd better be aware that is a subshell and the directory won't last.
		- But **source** does
		- And source does change the directory
		- And
	- It's a good idea check the number of arguments
	-
	-
-
- ---
- #### Flashcards
	- What is an argument? #flashcard
		- An **argument** is anything that can be put behind the name of a command or script
		- **ls -l /etc** has 2 arguments
	- What is an option? #flashcard
		- An **option** is an argument that changes the behavior of the command or script, and its functionality is programmed into the command
		- In **ls -l /etc**, **-l** is used as an option
	- What is a posicional parameter? #flashcard
		- A **posicional parameter** is another word for an argument.
		- It's the same thing as argument. But argument is a preferred name.
		- A **variable** is a key with a name that can refer to a specific value
	- How are quotes used in Bash? #flashcard
		- **Double quotes** (or **weak** quotes)are used to avoid interpretation of **spaces**
			- echo "my value"
		- **Single quotes** (or **strong** quotes)are used to avoid interpretation of **anything**
			- echo the current '$SHELL' is $SHELL