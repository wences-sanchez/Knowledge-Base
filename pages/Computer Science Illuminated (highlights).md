title:: Computer Science Illuminated (highlights)
deck:: [[O'Reilly-Learning::Computer Science Illuminated]]
author:: [[]]
full-title:: "Computer Science Illuminated"
category:: #books

tags:: O'Reilly-Learning

- Highlights first synced by [[Readwise]] [[Monday, 31-10-2022]]
	- 1.1 Computing Systems
		- -
			- __information hiding__ #flashcard
			  id:: 2ffd3c70-e9a4-4373-9eb5-ead5f8b30a8e
				- Information hiding is a design feature that gives rise to the abstractions that make something easier to work with. Information hiding and abstraction are two sides of the same coin.
		- -
	- 1.2 The History of Computing
		- -
			- First Generation (1951–1959)
			  id:: 6893662c-d7a9-464a-81b8-4d1ef0a57b83
			  Commercial computers in the first generation (from approximately 1951 to 1959) were built using vacuum tubes to store information. #flashcard
		- -
		- -
			- Second Generation (1959–1965)
			  id:: 78bec524-fe8c-488c-b595-4a27caddf41d
			  The advent of the transistor (for which John Bardeen, Walter H. Brattain, and William B. Shockley won a Nobel Prize) ushered in the second generation of commercial computers. The transistor replaced the vacuum tube as the main component in the hardware. #flashcard
		- -
		- -
			- Third Generation (1965–1971)
			  id:: 587286e8-79ee-4747-95f5-308a10d2dda5
			  In the second generation, transistors and other components for the computer were assembled by hand on printed circuit boards. The third generation was characterized by integrated circuits (ICs), solid pieces of silicon that contained the transistors, other components, and their connections. Integrated circuits were much smaller, cheaper, faster, and more reliable than printed circuit boards. #flashcard
		- -
		- -
			- __Transistors #flashcard
			  id:: 377d2ead-ec6b-40b8-abb3-4d38eec2139f
				- Transistors also were used for memory construction, where each transistor represented one bit of information. Integrated-circuit technology allowed memory boards to be built using transistors. Auxiliary storage devices were still needed because transistor memory was volatile; that is, the information went away when the power was turned off.
		- -
		- -
			- Fourth Generation (1971–?)
			  id:: 86b7f6f9-bed5-4cde-9383-7b5d938c38ff
			  Large-scale integration characterizes the fourth generation. From several thousand transistors on a silicon chip in the early 1970s, we had moved to a whole microcomputer on a chip by the middle of this decade. Main memory devices are still made almost exclusively out of chip technology. #flashcard
		- -
		- -
			- Parallel architectures offer several ways to increase the speed of execution. For example, a given step in a program can be separated into multiple pieces, and those pieces can be executed simultaneously on several individual processors. These machines are called SIMD (single-instruction, multiple-data-stream) computers. A second class of machines can work on different parts of a program simultaneously. These machines are called MIMD (multiple-instruction, multiple-data-stream) computers. #flashcard
			  id:: 802cd9d9-8d0c-4b79-b71f-8dccd5a77c35
		- -
		- -
			- A Brief History of Computing Software #flashcard
			  id:: 6de57613-c80a-4ab0-b255-1f78a3e71c4b
		- -
		- -
			- First-Generation Software (1951–1959)
			  id:: 91505b6c-931e-4a05-9c53-b1c090695a9c
			  The first programs were written using machine language, the instructions built into the electrical circuitry of a particular computer. Even the small task of adding two numbers together used three instructions written in binary (1s and 0s), and the programmer had to remember which combination of binary digits meant what. #flashcard
		- -
		- -
			- Because writing in machine code is so tedious, some programmers took the time to develop tools to help with the programming process. Programmers began writing programs in assembly language, which used mnemonic codes to represent each machine-language instruction. #flashcard
			  id:: 060e3bec-f442-4fa2-8390-de946ee121c5
		- -
		- -
			- Second-Generation Software (1959–1965)
			  id:: 31d82a35-2477-415e-b7de-a72cbb56fdbc
			  As hardware became more powerful, more powerful tools were needed to use it effectively. Assembly languages certainly presented a step in the right direction, but the programmer still was forced to think in terms of individual machine instructions. The second generation saw more powerful languages developed. These high-level languages allowed the programmer to write instructions using more English-like statements. #flashcard
		- -
		- -
			- __operating system #flashcard
			  id:: 32ce337c-ab12-4660-8186-4c6d7f7807c0
				- Third-Generation Software (1965–1971)
				  During the third generation of commercial computers, it became apparent that the human was slowing down the computing process. Computers were sitting idle while waiting for the computer operator to prepare the next job. The solution was to put the computer resources under the control of the computer—that is, to write a program that would determine which programs were run when. This kind of program was the first operating system.
		- -
		- -
			- About servers #flashcard
			  id:: d6de31cb-8e80-42ee-9dc8-6b6193bb2af1
				- For the user, time sharing is much like having his or her own machine. Each user is assigned a small slice of central processing time and then is put on hold while another user is serviced. Users generally aren’t even aware that there are other users. However, if too many people try to use the system at the same time, there can be a noticeable wait for a job to be completed.
		- -
		- -
			- systems VS applications programmers #flashcard
			  id:: 25357050-e4d7-4c00-adb5-e41ffcb8664d
				- By the end of the first generation, programmers had emerged who wrote tools for other programmers to use, giving rise to the distinction between systems programmers and applications programmers. However, the programmer was still the user. In the third generation, systems programmers were writing software for nonprogrammers to use. For the first time, there were computer users who were not programmers in the traditional sense.
		- -
		- -
			- Fourth Generation (1971–1989)
			  id:: 604402e3-7717-4376-805f-46d2610f3eda
			  The 1970s saw the introduction of better programming techniques called structured programming, a logical, disciplined approach to programming. The languages Pascal and Modula-2 were built on the principles of structured programming. BASIC, a language introduced for third-generation machines, was refined and upgraded to more structured versions. C, a language that allows the user to intersperse assembly-language statements in a high-level program, was also introduced. C++, a structured language that allows the user access to low-level statements as well, became the language of choice in the industry. #flashcard
		- -
		- -
			- Fifth Generation (1990–Present)
			  id:: 8430c3c0-0fc7-4435-9a57-9c77be08052d
			  The fifth generation is notable for three major events: the rise of Microsoft® as a dominant player in computer software, object-oriented design and programming, and the World Wide Web. #flashcard
		- -
		- -
			- Although the Internet had been around for decades, the World Wide Web made it easy to use the Internet to share information around the world. User-generated and user-edited content became the norm. #flashcard
			  id:: 66ba409e-7051-41cd-b487-383088700460
		- -