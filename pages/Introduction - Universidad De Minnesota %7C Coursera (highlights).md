title:: Introduction - Universidad De Minnesota | Coursera (highlights)
deck:: [[Across-the-Net]]
author:: [[coursera.org]]
full-title:: "Introduction - Universidad De Minnesota | Coursera"
category:: #articles
url:: https://www.coursera.org/learn/introduction-software-testing/lecture/ohzH2/introduction

- Highlights first synced by [[Readwise]] [[Monday, 31-10-2022]]
	- -
		- This is just an example of testing without being criticist against the application. #flashcard
		  id:: ba269dca-3bda-4830-991c-3673970c5dc6
			- So a developer writes two or three tests, they run it through the program.
	- -
	- -
		- What is the objective of the first course? #flashcard
		  id:: 08e6d136-5788-4507-bfca-824785ee30ed
			- And so what we're going to do, what our goal is for this course, is to make testing effective despite its incompleteness.
	- -
	- -
		- Even simple software has lots and lots possible tests that you can run against it. #flashcard
		  id:: 20c37a86-501a-45b6-8d18-7fd8c45dee75
	- -
	- -
		- But testing is always incomplete. #flashcard
		  id:: 8fffcb6f-aec9-416c-8dc0-bc83c4205643
	- -
	- -
		- So when you build something for, say, the United States government or another company, they not only want the software but they usually want a test suite that demonstrates the software does what it's supposed to do. #flashcard
		  id:: cdc26101-d306-4721-90cb-3f44eada0b46
	- -
	- -
		- Another reason we want to use testing is that oftentimes it's just necessary for the customer to accept the system. #flashcard
		  id:: 25c49ccc-d124-476b-b125-d5c6240ff10c
	- -
	- -
		- And that intended environment not only includes the software you write but the software you use and the hardware it runs on. #flashcard
		  id:: af35a95c-90fc-4693-a346-23d2ebcc82fe
	- -
	- -
		- Things like, does it have any integer overflows, or null pointer dereferences? And then testing, which is of course the focus of this course, where we have the software product itself, and and we're seeing if it does the right thing. #flashcard
		  id:: 1b863a02-3e95-431e-889a-bbaff91e97c6
	- -
	- -
		- Testing es uno más de las técnicas de V&V. Others are:
	- -
	- -
		- And why are we focusing on this area of verification and validation rather than all the others? Well, software testing is the only defect detection technique that can check the whole system. #flashcard
		  id:: 023e8d1e-4c57-4819-a671-cffcf37acf45
	- -
	- -
		- The key point is that Software Testing is the only software detection technique that can check the whole system #flashcard
		  id:: 0cfb5aa6-9469-4dd0-ad6d-c9a152a4e835
	- -
	- -
		- And the next thing we want to do is we want to apply multiple V&V, that is verification and validation techniques, throughout the development cycle. #flashcard
		  id:: bf00ee3e-dad4-4e59-92f2-a222689d438c
	- -
	- -
		- Why testing? #flashcard
		  id:: 779a8360-8aaa-40e3-b27c-8d15ea6cc99a
			- So our first question may be, why do we test? Why is it hard? It turns out that writing software is hard, and programmers make mistakes. And if we don't adequately test our systems, we may end up on front page news.
	- -
	- -
		- What do we want from testing? #flashcard
		  id:: d63b25c8-b5fd-4498-af64-a8a755746533
			- And we rely on software testing to help us get it right.
	- -
	- -
		- V&V explained #flashcard
		  id:: 2972adb1-0ab9-48fd-b533-594018a29ea4
			- To make sure software performs as expected, we have to do two things well. Those are verification and validation. And what we're trying to do is make sure that the software is going to meet the user's needs. So the first thing that we do is verification. This asks the question, "Are we building the software right?" So in this case, we assume we have some requirements and what we're trying to check is that the software conforms to its requirements. This is, of course, very important and a lot of the focus of software testing. But, another thing that we have to do is something called validation. And that is, "are we building the right product?" So maybe our requirements are wrong, and it doesn't actually meet the user's needs. So we have to perform a level of validation to make sure at the end of the process, and actually throughout, that we're building something not only that meets what we think the product should do, but also our customers think the product should do.
	- -