title:: Readwise/Programming TypeScript (highlights)
deck:: [[Other-Books::Programming TypeScript]]
author:: [[Boris Cherny]]
full-title:: "Programming TypeScript"
category:: #books

- Highlights first synced by [[Readwise]] [[Thursday, 02-02-2023]]
	- -
		- Supplemental material (code examples, exercises, etc.) is available for download at [*https://github.com/bcherny/programming-typescript-answers*](https://github.com/bcherny/programming-typescript-answers). #flashcard
		- ([View Highlight](https://read.readwise.io/read/01gr8sg2dt0vb40tjwmd9sfp3p))
	- -
	- Chapter 1. Introduction
		- Chapter 2. TypeScript: A 10_000 Foot View
			- -
				- How does TypeScript compile the code? #flashcard
					- Let’s start broad: programs are files that contain a bunch of text written by you, the programmer. That text is parsed by a special program called a *compiler*, which transforms it into an *abstract syntax tree (AST)*, a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate. The compiler then converts that AST to a lower-level representation called *bytecode*. You can feed that bytecode into another program called a *runtime* to evaluate it and get a result. So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code. The details vary, but for most languages this is an accurate high-level view.
					  
					  Once again, the steps are:
					  
					  1.  Program is parsed into an AST.
					    
					  2.  AST is compiled to bytecode.
					    
					  3.  Bytecode is evaluated by the runtime.
					    
					  
					  Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to… JavaScript code! You then run that JavaScript code like you normally would—in your browser, or with NodeJS, or by hand with a paper and pen (for anyone reading this after the machine uprising has begun).
					  
					  At this point you may be thinking: “Wait! In the last chapter you said TypeScript makes my code safer! When does that happen?”
					  
					  Great question. I actually skipped over a crucial step: after the TypeScript Compiler generates an AST for your program—but before it emits code—it *typechecks* your code.
				- ([View Highlight](https://read.readwise.io/read/01gr8t2ytgrg14dwqm9pq08n18))
			- -
			- -
				- ![](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/31439948/img-idm46320597968936-prts_0201.png)Figure 2-1. Compiling and running TypeScript
				  
				  Steps 1–3 are done by TSC, and steps 4–6 are done by the JavaScript runtime that lives in your browser, NodeJS, or whatever JavaScript engine you’re using. #flashcard
				- ([View Highlight](https://read.readwise.io/read/01gr8t6dr2vvsmd396ry7qwgf5))
			- -
			- -
				- In this process, steps 1–2 use your program’s types; step 3 does not. That’s worth reiterating: *when TSC compiles your code from TypeScript to JavaScript, it won’t look at your types*. That means your program’s types will never affect your program’s generated output, and are only used for typechecking. This feature makes it foolproof to play around with, update, and improve your program’s types, without risking breaking your application. #flashcard
				- ([View Highlight](https://read.readwise.io/read/01gr8t9ae4q9vn4gy8gr4fszzj))
			- -
			- -
				- About types in TypeScript #flashcard
					- To explicitly signal to TypeScript what your types are, use annotations. Annotations take the form *value: type* and tell the typechecker, “Hey! You see this *value* here? Its type is *type*.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):
					  
					    let
					  
					  And if you want TypeScript to infer your types for you, just leave them off and let TypeScript get to work:
					  
					    let
					  
					  Right away, you’ll notice how good TypeScript is at inferring types for you. If you leave off the annotations, the types are the same! Throughout this book, we will use annotations only when necessary, and let TypeScript work its inference magic for us whenever possible.
				- ([View Highlight](https://read.readwise.io/read/01gr8v282971k5cmbmb41v2eeb))
			- -
			- -
				- Table 2-1. Comparing JavaScript’s and TypeScript’s type systems
				  
				  Type system feature
				  
				  JavaScript
				  
				  TypeScript
				  
				  **How are types bound?**
				  
				  Dynamically
				  
				  Statically
				  
				  **Are types automatically converted?**
				  
				  Yes
				  
				  No (mostly)
				  
				  **When are types checked?**
				  
				  At runtime
				  
				  At compile time
				  
				  **When are errors surfaced?**
				  
				  At runtime (mostly)
				  
				  At compile time (mostly) #flashcard
				- ([View Highlight](https://read.readwise.io/read/01gr8v6h6257sch1bbx0ygj3sr))
			- -
			- -
				- Dynamic type binding means that JavaScript needs to actually run your program to know the types of things in it. JavaScript doesn’t know your types before running your program.
				  
				  TypeScript is a *gradually typed* language. That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped program TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users.
				  
				  This gradual typing is really useful for migrating legacy codebases from untyped JavaScript to typed TypeScript (more on that in [“Gradually Migrating from JavaScript to TypeScript”](#migrating-to-typescript)), but unless you’re in the middle of migrating your codebase, you should aim for 100% type coverage. #flashcard
				- ([View Highlight](https://read.readwise.io/read/01gr8vac0j5t4184vds49egtee))
			- -